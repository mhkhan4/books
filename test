using InterceptApis.Core.Interfaces.Providers;
using InterceptApis.Core.Interfaces.Services;
using InterceptApis.Core.Mappers;
using InterceptApis.Core.Models.LegacyRest.Accounts;
using InterceptApis.Core.Models.LegacyRest.Card;
using InterceptApis.Shared.Constants;
using InterceptApis.Shared.Enums.Legacy;
using InterceptApis.Shared.Exceptions;
using InterceptApis.Shared.Filters;
using InterceptApis.Shared.Helpers;
using InterceptApis.Shared.Models;

namespace InterceptApis.Core.Services
{
    public class AccountsService : IAccountsService
    {
        private readonly ICbsAccountsProvider _cbsAccountsProvider;
        private readonly AccountsMapper _accountsMapper;

        public AccountsService(ICbsAccountsProvider cbsAccountsProvider)
        {
            _cbsAccountsProvider = cbsAccountsProvider;
            _accountsMapper = new AccountsMapper();
        }

        public Models.Cbs.Accounts.Account GetCbsAccount(User user, int id, AccountsFilter filter)
        {
            var accounts = _cbsAccountsProvider.GetAccounts(user, filter);

            var accountsList = accounts.Where(ac => ac.Status.Code != ProductCode.ClosedStatusCode).ToList();
            if (!accountsList.Any())
            {
                throw new NotFoundException(ErrorCode.NotFoundError, nameof(ErrorCode.NotFoundError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.NotFoundError).GetDeveloperDescription<ErrorCode>());
            }
            _accountsMapper.GenerateAccountIndexes(accountsList, user.MtbToken);

            var account = accountsList.FirstOrDefault(q => q.Index == id);

            return account;
        }

        public AccountSummary GetAccountSummary(User user, AccountsFilter filter)
        {
            var accounts = _cbsAccountsProvider.GetAccounts(user, filter);
            var accountsList = accounts.Where(x => x.Status != null)
                                        .Where(ac => ac.Status.Code != ProductCode.ClosedStatusCode).ToList();
            if (!accountsList.Any())
            {
                throw new NotFoundException(ErrorCode.AccountsNotFound, nameof(ErrorCode.AccountsNotFound).GetUserDescription<ErrorCode>(), nameof(ErrorCode.AccountsNotFound).GetDeveloperDescription<ErrorCode>());
            }
            _accountsMapper.GenerateAccountIndexes(accountsList, user.MtbToken);
            var accountSummary = new AccountSummary
            {
                CheckingAccountsResults = _accountsMapper.MapCheckingAccounts(accountsList.Where(x => ProductCode.CheckingAccounts.Contains(x.ProductCode.ToUpper()))),
                InvestmentAccountsResults = _accountsMapper.MapInvestmentAccounts(accountsList.Where(x => ProductCode.InvestmentAccounts.Contains(x.ProductCode.ToUpper()))),
                CreditAccountsResults = _accountsMapper.MapCreditAccounts(accountsList.Where(x => ProductCode.CreditAccounts.Contains(x.ProductCode.ToUpper()))),
                LoanAccountsResults = _accountsMapper.MapLoanAccounts(accountsList.Where(x => ProductCode.LoanAccounts.Contains(x.ProductCode.ToUpper())))
            };

            return accountSummary;
        }

        public List<Account> GetTransactionAccounts(User user, AccountsFilter filter)
        {
            var accounts = _cbsAccountsProvider.GetAccounts(user, filter);

            switch (filter.Module)
            {
                case Module.CheckDeposit:
                    if (filter.AccountListType == AccountListType.To)
                    {
                        var checkingAccounts = _accountsMapper.MapCheckingAccounts(accounts
                            .Where(x => ProductCode.CheckingAccounts.Contains(x.ProductCode.ToUpper())));

                        return _accountsMapper.MapTransactionAccounts(checkingAccounts);
                    }
                    break;
            }

            throw new BadRequestException(ErrorCode.InvalidRequest, nameof(ErrorCode.InvalidRequest).GetUserDescription<ErrorCode>(), nameof(ErrorCode.InvalidRequest).GetDeveloperDescription<ErrorCode>());
        }

        public AccountDetails GetAccountDetails(User user, int id, AccountsFilter filter)
        {
            var accounts = GetAccountSummary(user, filter);
            var key = GetCbsAccountKeyFromIndex(accounts, id);

            var cbsAccountDetails = _cbsAccountsProvider.GetAccountDetails(user, key, filter) ?? throw new NotFoundException(ErrorCode.NotFoundError, nameof(ErrorCode.NotFoundError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.NotFoundError).GetDeveloperDescription<ErrorCode>());
            var legacyAccountDetails = _accountsMapper.MapAccountDetails(cbsAccountDetails);
            legacyAccountDetails.AccountInfo.AccountIndex = id;
            legacyAccountDetails.AccountInfo.AccountKey.AccountIndex = id;

            return legacyAccountDetails;
        }

        private string GetCbsAccountKeyFromIndex(AccountSummary accounts, int id)
        {
            var key = string.Empty;

            foreach (var account in accounts.CheckingAccountsResults)
            {
                if (account.AccountIndex == id)
                {
                    key = account.CbsAccountKey;
                    return key;
                }
            }

            foreach (var account in accounts.CreditAccountsResults)
            {
                if (account.AccountIndex == id)
                {
                    key = account.CbsAccountKey;
                    return key;
                }
            }

            foreach (var account in accounts.InvestmentAccountsResults)
            {
                if (account.AccountIndex == id)
                {
                    key = account.CbsAccountKey;
                    return key;
                }
            }

            foreach (var account in accounts.LoanAccountsResults)
            {
                if (account.AccountIndex == id)
                {
                    key = account.CbsAccountKey;
                    return key;
                }
            }

            return key;
        }

        public List<Card> GetLinkedAccounts(User user, string accountNumber, string productCode)
        {
            var cbsAccountDetails = _cbsAccountsProvider.GetLinkedAccounts(user, accountNumber, productCode) ?? throw new NotFoundException(ErrorCode.NotFoundError, nameof(ErrorCode.NotFoundError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.NotFoundError).GetDeveloperDescription<ErrorCode>());
            var linkedAccounts = _accountsMapper.MapLinkedAccountDetails(cbsAccountDetails.Single());
            return linkedAccounts;
        }
    }
}








using InterceptApis.Core.Interfaces.Services;
using InterceptApis.Core.Models.LegacyRest.Accounts;
using InterceptApis.Shared.Binders;
using InterceptApis.Shared.Constants;
using InterceptApis.Shared.Enums.Legacy;
using InterceptApis.Shared.Filters;
using InterceptApis.Shared.Models;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using System.ComponentModel.DataAnnotations;
using System.Net.Mime;
using HttpGetAttribute = Microsoft.AspNetCore.Mvc.HttpGetAttribute;
using RouteAttribute = Microsoft.AspNetCore.Mvc.RouteAttribute;

namespace InterceptApis.WebApi.Controllers
{
    [Route("v3/accounts")]
    [ApiController]
    [Produces(MediaTypeNames.Application.Json)]
    public class AccountsController : ControllerBase
    {
        private readonly IAccountsService _accountsService;

        public AccountsController(IAccountsService accountsService)
        {
            _accountsService = accountsService;
        }

        /// <summary>
        /// Get accounts
        /// </summary>
        /// <param name="user"></param>
        /// <param name="filter"></param>
        /// <returns>List of accounts</returns>
        [ProducesResponseType(typeof(AccountSummary), StatusCodes.Status200OK)]
        [HttpGet]
        public IActionResult GetAccountSummary([MtbToken, Required] User user, [FromQuery] AccountsFilter filter)
        {
            filter.RelatedAccounts = ServiceConstant.Primary;
            var accounts = _accountsService.GetAccountSummary(user, filter);
            var cardsJson = JsonConvert.SerializeObject(accounts, Formatting.Indented);
            var accountsList = System.Text.Json.JsonSerializer.Deserialize(cardsJson, typeof(object));
            return Ok(accountsList);
        }

        /// <summary>
        /// Retrieves (default from list) accounts list if there are no filters mentioned 
        /// Retrieves TO list for the mentioned account index in the query
        /// </summary>
        /// <param name="user"></param>
        /// <param name="filter"></param>
        /// <returns>List of transaction (MCD) accounts</returns>
        [ProducesResponseType(typeof(List<Account>), StatusCodes.Status200OK)]
        [Route("transactionaccounts")]
        [HttpGet]
        public IActionResult GetTransactionAccounts([MtbToken, Required] User user, [FromQuery] AccountsFilter filter)
        {
            filter.AccountListType = AccountListType.To;
            filter.Module = Module.CheckDeposit;

            return Ok(_accountsService.GetTransactionAccounts(user, filter));
        }

        /// <summary>
        /// Get the account details
        /// </summary>
        /// <param name="user"></param>
        /// <param name="id"></param>
        /// <param name="filter"></param>
        /// <returns>Details of a specified account</returns>
        [ProducesResponseType(typeof(AccountDetails), StatusCodes.Status200OK)]
        [Route("{id:int}")]
        [HttpGet]
        public IActionResult GetAccountDetails([MtbToken, Required] User user, [Required] int id, [FromQuery] AccountsFilter filter)
        {
            return Ok(_accountsService.GetAccountDetails(user, id, filter));
        }
    }
}




















//wrapper
using InterceptApis.Shared.Constants;
using InterceptApis.Shared.Exceptions;
using InterceptApis.Shared.Helpers;
using InterceptApis.Shared.Interfaces;
using InterceptApis.Shared.Models;
using Serilog;
using System.Diagnostics;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace InterceptApis.Shared.Services
{
    public class HttpClientWrapper : IHttpClientWrapper
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly IAuthenticationProvider _cbsAuthenticationProvider;
        private readonly ICbsStatusResults _cbsStatusResults;
        private readonly ILogger _logger;
        public HttpClientWrapper(IHttpClientFactory httpClientFactory, IAuthenticationProvider cbsAuthenticationProvider, ICbsStatusResults cbsStatusResults, ILogger logger)
        {
            _httpClientFactory = httpClientFactory;
            _cbsAuthenticationProvider = cbsAuthenticationProvider;
            _cbsStatusResults = cbsStatusResults;
            _logger = logger;
        }

        public Task<tOut> Post<tIn, tOut>(tIn t, string uriPath, string namedClient, User user)
        {
            tOut tOutResponse;
            var httpClient = _httpClientFactory.CreateClient(namedClient);
            var cbsToken = user.SourceToken ?? _cbsAuthenticationProvider.GenerateJwt(user);

            if (!string.IsNullOrEmpty(cbsToken))
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {cbsToken}");
                httpClient.DefaultRequestHeaders.Add("corr_id", $"{Activity.Current?.RootId}");
            }
            user.SourceToken = cbsToken;
            var httpResponseMessage = httpClient.PostAsync(uriPath, new StringContent(JsonSerializer.Serialize(t), Encoding.UTF8, "application/json")).Result;
            if (httpResponseMessage.IsSuccessStatusCode)
            {
                var contentStream = httpResponseMessage.Content.ReadAsStringAsync().Result;
                var options = new JsonSerializerOptions()
                {
                    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString,
                    Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                    PropertyNameCaseInsensitive = true
                };
                tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream, options);
            }
            else
            {
                FormatHttpResponseStatus(httpResponseMessage);
                return null;
            }
            return Task.FromResult<tOut>(tOutResponse);
        }

        public Task<tOut> Put<tIn, tOut>(tIn t, string uriPath, string namedClient, User user)
        {
            tOut tOutResponse;
            var httpClient = _httpClientFactory.CreateClient(namedClient);
            var cbsToken = user.SourceToken ?? _cbsAuthenticationProvider.GenerateJwt(user);
            if (!string.IsNullOrEmpty(cbsToken))
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {cbsToken}");
                httpClient.DefaultRequestHeaders.Add("corr_id", $"{Activity.Current?.RootId}");
                httpClient.DefaultRequestHeaders.Add("send-notification", "false");
            }
            user.SourceToken = cbsToken;
            var httpResponseMessage = httpClient.PutAsync(uriPath, new StringContent(JsonSerializer.Serialize(t), Encoding.UTF8, "application/json")).Result;
            if (httpResponseMessage.IsSuccessStatusCode)
            {
                var contentStream = httpResponseMessage.Content.ReadAsStringAsync().Result;
                var options = new JsonSerializerOptions()
                {
                    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString,
                    Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                    PropertyNameCaseInsensitive = true
                };
                if (string.IsNullOrEmpty(contentStream))
                {
                    contentStream = CommonConstants.SuccessMessage;
                    tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream, options);
                }
                else
                {
                    tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream);
                }
            }
            else
            {
                FormatHttpResponseStatus(httpResponseMessage);
                return null;
            }
            return Task.FromResult<tOut>(tOutResponse);
        }

        public Task<tOut> Get<tOut>(string uriPath, string namedClient, User user)
        {
            tOut tOutResponse;
            var httpClient = _httpClientFactory.CreateClient(namedClient);
            var cbsToken = user.SourceToken ?? _cbsAuthenticationProvider.GenerateJwt(user);
            if (!string.IsNullOrEmpty(cbsToken))
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {cbsToken}");
                httpClient.DefaultRequestHeaders.Add("corr_id", $"{Activity.Current?.RootId}");
            }
            user.SourceToken = cbsToken;

            var httpResponseMessage = httpClient.GetAsync(uriPath, HttpCompletionOption.ResponseHeadersRead).Result;

            if (httpResponseMessage.IsSuccessStatusCode)
            {
                var options = new JsonSerializerOptions()
                {
                    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString,
                    Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                    PropertyNameCaseInsensitive = true
                };

                var contentStream = httpResponseMessage.Content.ReadAsStringAsync().Result;
                tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream, options);
            }
            else
            {
                FormatHttpResponseStatus(httpResponseMessage);
                return null;
            }
            return Task.FromResult<tOut>(tOutResponse);
        }

        public Task<tOut> Delete<tOut>(string uriPath, string namedClient, User user)
        {
            tOut tOutResponse;
            var httpClient = _httpClientFactory.CreateClient(namedClient);
            var cbsToken = user.SourceToken ?? _cbsAuthenticationProvider.GenerateJwt(user);
            if (!string.IsNullOrEmpty(cbsToken))
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {cbsToken}");
                httpClient.DefaultRequestHeaders.Add("corr_id", $"{Activity.Current?.RootId}");
            }
            user.SourceToken = cbsToken;
            var httpResponseMessage = httpClient.DeleteAsync(uriPath).Result;
            if (httpResponseMessage.IsSuccessStatusCode)
            {
                var contentStream = httpResponseMessage.Content.ReadAsStringAsync().Result;
                if (string.IsNullOrEmpty(contentStream))
                {
                    contentStream = CommonConstants.SuccessMessage;
                    tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream);
                }
                else
                {
                    tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream);
                }
            }
            else
            {
                FormatHttpResponseStatus(httpResponseMessage);
                return null;
            }
            return Task.FromResult<tOut>(tOutResponse);
        }
        private void FormatHttpResponseStatus(HttpResponseMessage httpResponse)
        {
            var cbsStatusCode = string.Empty;
            var cbsErrorMessage = string.Empty;
            if (httpResponse.Headers.TryGetValues("err_msg", out var headerValues1))
            {
                cbsErrorMessage = headerValues1.FirstOrDefault();
            }
            if (httpResponse.Headers.TryGetValues("err_status", out var headerValues2))
            {
                cbsStatusCode = headerValues2.FirstOrDefault();
            }
            var statusResult = _cbsStatusResults.GetStatusObject(cbsStatusCode, (int)httpResponse.StatusCode);
            _logger.Error($"{"CBA Service Error"},{cbsStatusCode},{cbsErrorMessage}");
            throw httpResponse.StatusCode switch
            {
                System.Net.HttpStatusCode.NotFound => new NotFoundException(cbsStatusCode, cbsErrorMessage, cbsErrorMessage),
                System.Net.HttpStatusCode.BadRequest => new BadRequestException(cbsStatusCode, cbsErrorMessage, cbsErrorMessage),
                System.Net.HttpStatusCode.Unauthorized => new UnauthorizedException(cbsStatusCode, cbsErrorMessage, cbsErrorMessage),
                _ => new ExternalServiceException(ErrorCode.ExternalServiceError, "CBA service error", "Contact CBA team for error", null),
            };
        }

        public Task<tOut> PostEmh<tIn, tOut>(tIn t, string uriPath, string namedClient, User user)
        {
            tOut tOutResponse;
            var httpClient = _httpClientFactory.CreateClient(namedClient);
            var httpResponseMessage = httpClient.PostAsync(uriPath, new StringContent(JsonSerializer.Serialize(t), Encoding.UTF8, "application/json")).Result;
            if (httpResponseMessage.IsSuccessStatusCode)
            {
                var contentStream = httpResponseMessage.Content.ReadAsStringAsync().Result;
                var options = new JsonSerializerOptions()
                {
                    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString,
                    Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) },
                    PropertyNameCaseInsensitive = true
                };
                tOutResponse = JsonSerializer.Deserialize<tOut>(contentStream, options);
            }
            else
            {
                throw httpResponseMessage.StatusCode switch
                {
                    System.Net.HttpStatusCode.NotFound => new NotFoundException(ErrorCode.NotFoundError, nameof(ErrorCode.NotFoundError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.NotFoundError).GetDeveloperDescription<ErrorCode>()),
                    System.Net.HttpStatusCode.BadRequest => new BadRequestException(ErrorCode.BadRequest, nameof(ErrorCode.BadRequest).GetUserDescription<ErrorCode>(), nameof(ErrorCode.BadRequest).GetDeveloperDescription<ErrorCode>()),
                    System.Net.HttpStatusCode.Unauthorized => new UnauthorizedException(ErrorCode.Unauthorized, nameof(ErrorCode.Unauthorized).GetUserDescription<ErrorCode>(), nameof(ErrorCode.Unauthorized).GetDeveloperDescription<ErrorCode>()),
                    _ => new ExternalServiceException(ErrorCode.ExternalServiceError, "EMH service error", "Contact EMH team for error", null),
                };
            }
            return Task.FromResult<tOut>(tOutResponse);
        }
    }
}










package com.mtb.vlp.policy.config;

import com.mtb.vlp.policy.filters.WebClientErrorFilter;
import io.netty.channel.ChannelOption;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;
import java.time.Duration;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;
import reactor.netty.resources.ConnectionProvider;
import reactor.netty.transport.logging.AdvancedByteBufFormat;

@Slf4j
@Configuration
public class WebClientConfig {
  @Value("${web-client.log-buffer.type:TEXTUAL}")
  private AdvancedByteBufFormat logBufferType;

  public static final String pingClientName = "PING";
  public static final String cbaUserClientName = "CBA-USERS";
  public static final String cbaContactsClientName = "CBA-CONTACTS";
  public static final String cbaAuthClientName = "CBA-AUTH";
  public static final String svSessionClientName = "SV-SESSION";
  public static final String eflRsaClientName = "EFL-RSA";
  public static final String domainClientName = "DOMAIN";
  public static final String xrefClientName = "XREF";

  /**
   * Connect to CBS Users
   *
   * @param rootUri Properties file injected
   * @param connectionTimeoutMs Properties file injected
   * @param responseTimeoutMs Properties file injected
   * @param readTimeoutMs Properties file injected
   * @param writeTimeoutMs Properties file injected
   * @param webClientBuilder Spring injected
   * @return
   */
  @Bean
  public WebClient cbsUsersClient(
      @Value("${cbs.users.rest.uri.root}") String rootUri,
      @Value("${cbs.users.rest.max.connections}") int maxConnections,
      @Value("${cbs.users.rest.timeout.read}") int connectionTimeoutMs,
      @Value("${cbs.users.rest.timeout.read}") int responseTimeoutMs,
      @Value("${cbs.users.rest.timeout.read}") int readTimeoutMs,
      @Value("${cbs.users.rest.timeout.write}") int writeTimeoutMs,
      WebClient.Builder webClientBuilder) {
    return webClientBuilder
        .baseUrl(rootUri)
        .clientConnector(
            new ReactorClientHttpConnector(
                createHttpClient(
                    cbaUserClientName,
                    maxConnections,
                    connectionTimeoutMs,
                    responseTimeoutMs,
                    readTimeoutMs,
                    writeTimeoutMs)))
        .filter(WebClientErrorFilter.processCbaUserErrorResponse())
        .build();
  }

  }
