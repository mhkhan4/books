using InterceptApis.Shared.Configuration;
using InterceptApis.Shared.Constants;
using InterceptApis.Shared.Exceptions;
using InterceptApis.Shared.Helpers;
using InterceptApis.Shared.Interfaces;
using InterceptApis.Shared.Models;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.Extensions.Options;

namespace InterceptApis.Shared.Binders
{
    public class UserModelBinder : IModelBinder
    {
        private readonly IEmhService _emhService;
        private readonly CbsConfiguration _cbsConfig;

        public UserModelBinder(IEmhService emhService, IOptions<CbsConfiguration> cbsConfig)
        {
            _emhService = emhService;
            _cbsConfig = cbsConfig.Value;
        }
        public async Task BindModelAsync(ModelBindingContext bindingContext)
        {
            if (bindingContext == null)
            {
                throw new ArgumentNullException(nameof(bindingContext));
            }
            var headerKey = bindingContext.ModelMetadata.BinderModelName;
            if (string.IsNullOrEmpty(headerKey))
            {
                headerKey = "MTBToken";
            }
            var headerValue = bindingContext.HttpContext.Request.Headers[headerKey];
            if (!string.IsNullOrEmpty(headerValue))
            {
                try
                {
                    var cacheManager = (IRedisService)bindingContext.HttpContext.RequestServices.GetService(typeof(IRedisService));
                    var user = await cacheManager.GetHashEntryAsync(headerValue, "User");
                    if (user != null)
                    {
                        var cacheUser = Newtonsoft.Json.JsonConvert.DeserializeObject<LegacyUser>(user);
                        if (string.IsNullOrEmpty(cacheUser.PartyId))
                        {
                            var partyPreference = _emhService.GetPartyId(cacheUser.UserKey.AuthInternalId);
                            if (partyPreference != null)
                            {
                                cacheUser.PartyId = Convert.ToString(partyPreference.partyId);
                            }
                            else
                            {
                                throw new InternalServerException(ErrorCode.InternalServerError, nameof(ErrorCode.InternalServerError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.InternalServerError).GetDeveloperDescription<ErrorCode>());
                            }
                        }
                        bindingContext.Model = new User
                        {
                            MtbToken = headerValue,
                            AuthId = cacheUser.UserKey.AuthInternalId,
                            PartyId = cacheUser.PartyId,
                            CustomerName = cacheUser.CustomerName.Replace("  ", " "),
                            CustomerTie = Convert.ToInt32(cacheUser.TieBreaker),
                            CompanyId = 96,
                            ZelleId = cacheUser.ZelleId,
                            UserKey = new UserKey
                            {
                                UserType = cacheUser.UserKey.UserType,
                                AuthInternalId = cacheUser.UserKey.AuthInternalId,
                                IsSubUser = cacheUser.UserKey.IsSubUser
                            },
                            UserAddress = new Address
                            {
                                Address0 = cacheUser.UserAddress?.Address0,
                                Address1 = cacheUser.UserAddress?.Address1,
                                Address2 = cacheUser.UserAddress?.Address2,
                                Address3 = cacheUser.UserAddress?.Address3,
                                Address4 = cacheUser.UserAddress?.Address4,
                                Address5 = cacheUser.UserAddress?.Address5,
                                City = cacheUser.UserAddress?.City,
                                State = cacheUser.UserAddress?.State,
                                ZipCode = cacheUser.UserAddress?.ZipCode,
                                Country = cacheUser.UserAddress?.Country
                            },
                            Roles = cacheUser.Roles
                        };
                    }
                    else
                    {
                        bindingContext.Model = new User
                        {
                            MtbToken = headerValue,
                            AuthId = _cbsConfig.TestUser.AuthId,
                            PartyId = _cbsConfig.TestUser.PartyId,
                            CustomerName = _cbsConfig.TestUser.CustomerName,
                            CustomerTie = _cbsConfig.TestUser.CustomerTie,
                            CompanyId = _cbsConfig.TestUser.CompanyId,
                            ZelleId = _cbsConfig.TestUser.ZelleId,
                            UserKey = new UserKey
                            {
                                UserType = _cbsConfig.TestUser.UserKey.UserType,
                                AuthInternalId = _cbsConfig.TestUser.UserKey.AuthInternalId
                            },
                            UserAddress = new Address
                            {
                                Address1 = _cbsConfig.TestUser.UserAddress.Address1,
                                City = _cbsConfig.TestUser.UserAddress.City,
                                State = _cbsConfig.TestUser.UserAddress.State,
                                ZipCode = _cbsConfig.TestUser.UserAddress.ZipCode,
                                Country = _cbsConfig.TestUser.UserAddress.Country
                            },
                            Roles = new List<string> { UserRoles.P2P }
                        };
                    }
                    bindingContext.Result = ModelBindingResult.Success(bindingContext.Model);
                }
                catch (Exception ex)
                {
                    throw new InternalServerException(ErrorCode.InternalServerError, nameof(ErrorCode.InternalServerError).GetUserDescription<ErrorCode>(), nameof(ErrorCode.InternalServerError).GetDeveloperDescription<ErrorCode>(), ex);
                }
            }
        }
    }
}




[AttributeUsage(AttributeTargets.Parameter)]
    public class MtbTokenAttribute : Attribute, IBinderTypeProviderMetadata, IModelNameProvider
    {
        public BindingSource BindingSource => BindingSource.Header;

        public string Name => "MTBToken";

        public Type BinderType => typeof(UserModelBinder);
    }





using InterceptApis.Shared.Configuration;
using InterceptApis.Shared.Interfaces;
using Newtonsoft.Json;
using StackExchange.Redis;

namespace InterceptApis.Shared.Services
{

    public class RedisService : IRedisService
    {
        private static readonly Lazy<ConfigurationOptions> _configOptions = new(() =>
        {
            var options = new ConfigurationOptions();
            options.EndPoints.Add($"{_redisConfig.Host}:{_redisConfig.Port}");
            options.Password = _redisConfig.Password;
            options.ConnectTimeout = 5000;
            options.SyncTimeout = 5000;
            options.AbortOnConnectFail = false;
            options.ConnectRetry = 3;
            return options;
        });
        private static ConnectionMultiplexer _redisClient;
        private static RedisConfiguration _redisConfig;
        public RedisService(RedisConfiguration redisConfig)
        {
            _redisConfig = redisConfig;
            try
            {
                var conn = new Lazy<ConnectionMultiplexer>(() => ConnectionMultiplexer.Connect(_configOptions.Value));
                _redisClient = conn.Value;
            }
            catch (Exception ex)
            {
                throw new Exception("Error Connecting to Redis Server", ex);
            }
        }
        private IDatabase GetRedisDb()
        {
            return _redisClient.GetDatabase();
        }

        public async Task<string> GetHashEntryAsync(string hashKey, string hashEntryKey)
        {
            var db = GetRedisDb();
            if (await db.HashExistsAsync(hashKey, hashEntryKey))
            {
                await db.KeyExpireAsync(hashKey, TimeSpan.FromSeconds(3600));
                return await db.HashGetAsync(hashKey, hashEntryKey);
            }

            return null;
        }

        public T GetHashEntry<T>(string hashKey, string hashEntryKey)
        {
            var db = GetRedisDb();
            if (db.HashExists(hashKey, hashEntryKey))
            {
                db.KeyExpire(hashKey, TimeSpan.FromSeconds(3600));
                return JsonConvert.DeserializeObject<T>(db.HashGet(hashKey, hashEntryKey));
            }

            return default(T);
        }
    }
}






import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.core.ReactiveHashOperations;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Duration;

@Service
public class RedisService {
    // ReactiveRedisTemplate is a class provided by Spring Data Redis
    // which provides reactive operations to interact with Redis.
    private final ReactiveRedisTemplate<String, String> reactiveRedisTemplate;

    // ReactiveHashOperations provides methods for working with Redis hashes in a reactive way.
    private ReactiveHashOperations<String, String, String> reactiveHashOps;

    public RedisService(ReactiveRedisTemplate<String, String> reactiveRedisTemplate) {
        this.reactiveRedisTemplate = reactiveRedisTemplate;

        // We use the opsForHash() method of ReactiveRedisTemplate to get a ReactiveHashOperations instance.
        this.reactiveHashOps = reactiveRedisTemplate.opsForHash();
    }

    public Mono<String> getHashEntryAsync(String hashKey, String hashEntryKey) {
        // The hasKey() method checks if the hash at hashKey has an entry for hashEntryKey.
        // The result is a Mono<Boolean> that we can use with flatMap() to perform the next operation.
        return reactiveHashOps.hasKey(hashKey, hashEntryKey)
            .flatMap(exists -> {
                if (exists) {
                    // If the hash has an entry for hashEntryKey, we set an expiration time for the key
                    // and retrieve the value of the hash entry.

                    // The expire() method sets the key to expire after the specified duration.
                    // In this case, we set it to expire after 3600 seconds (1 hour).
                    reactiveRedisTemplate.expire(hashKey, Duration.ofSeconds(3600));

                    // The get() method retrieves the value of the hash entry.
                    // The result is a Mono<String> that contains the value.
                    return reactiveHashOps.get(hashKey, hashEntryKey);
                }
                // If the hash does not have an entry for hashEntryKey, we return an empty Mono.
                return Mono.empty();
            });
    }
}





import com.fasterxml.jackson.databind.ObjectMapper;

@Service
public class RedisService {
    // ...

    public Mono<User> getUserAsync(String hashKey) {
        return getHashEntryAsync(hashKey, "User")
            .map(userData -> {
                try {
                    // ObjectMapper is a class from the Jackson library that can convert between JSON and Java objects.
                    ObjectMapper objectMapper = new ObjectMapper();

                    // Here, we're using ObjectMapper to convert the user data from JSON format to a User object.
                    return objectMapper.readValue(userData, User.class);
                } catch (Exception ex) {
                    // If something goes wrong while converting the user data, we throw an exception.
                    throw new RuntimeException("Failed to deserialize user data", ex);
                }
            });
    }
}




import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Optional;

@Service
public class RedisService {
    
    private HashOperations hashOperations;
    private ObjectMapper mapper;

    @Autowired
    public RedisService(RedisTemplate<String, Object> redisTemplate, ObjectMapper mapper) {
        this.hashOperations = redisTemplate.opsForHash();
        this.mapper = mapper;
    }

    public Mono<User> getUser(String token) {
        return Mono.fromSupplier(() -> hashOperations.get(token, "User"))
            .flatMap(json -> {
                if (json != null) {
                    try {
                        return Mono.just(mapper.readValue((String) json, User.class));
                    } catch (Exception e) {
                        return Mono.error(e);
                    }
                } else {
                    return Mono.empty();
                }
            });
    }
}





